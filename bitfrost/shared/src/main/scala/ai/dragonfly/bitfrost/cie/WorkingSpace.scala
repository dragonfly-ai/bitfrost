package ai.dragonfly.bitfrost.cie

import Jama.Matrix

import ai.dragonfly.math.*
import vector.{VectorValues, Vector2, Vector3, dimensionCheck}
import matrix.*
import matrix.util.*
import ai.dragonfly.math.matrix.util.given_Dimensioned_Matrix
import ai.dragonfly.math.matrix.util.asColumnMatrix

import ai.dragonfly.bitfrost.*

import scala.language.implicitConversions

trait WorkingSpace {

  val compander: Compander
  val primaries: ChromaticityPrimaries
  val illuminant: Illuminant

  lazy val M: Matrix = (
    ((primaries.xyzXrgbInv * illuminant.vector.asColumnMatrix) * Matrix.identity(3, 3)) * primaries.xyzXrgb_T
  ).transpose()

  lazy val M_inverse: Matrix = M.inverse()

  import ai.dragonfly.bitfrost

  trait CommonColor[C <: CommonColor[C]] extends ColorVector[C] {
    def toNRGB: NRGB
  }

  trait CommonColorSpace[C <: CommonColor[C]] extends ColorVectorSpace[C] {
    //  def fromARGB(argb: ARGB):C
    def fromNRGB(nrgb: NRGB): C
  }


  trait PerceptualColor[C <: PerceptualColor[C]] extends ColorVector[C] {
    def toXYZ(using nativeWorkingSpace: WorkingSpace): XYZ
  }

  trait PerceptualColorSpace[C <: PerceptualColor[C]] extends ColorVectorSpace[C] {
    def fromXYZ(xyz: XYZ): C
  }


  object ARGB extends DiscreteColorSpace[ARGB] {
    def apply(argb: Int): ARGB = new ARGB(argb)

    /**
     * Factory method to create a fully opaque ARGB instance from separate, specified red, green, blue components and
     * a default alpha value of 255.
     * Parameter values are derived from the least significant byte.  Integer values that range outside of [0-255] may
     * give unexpected results.  For values taken from user input, sensors, or otherwise uncertain sources, consider using
     * the factory method in the Color companion object.
     *
     * @see [[ai.dragonfly.color.ColorVectorSpace.argb]] for a method of constructing ARGB objects that validates inputs.
     * @param red   integer value from [0-255] representing the red component in RGB space.
     * @param green integer value from [0-255] representing the green component in RGB space.
     * @param blue  integer value from [0-255] representing the blue component in RGB space.
     * @return an instance of the ARGB case class.
     * @example {{{ val c = ARGB(72,105,183) }}}
     */
    inline def apply(red: Int, green: Int, blue: Int): ARGB = apply(255, red, green, blue)


    /**
     * Factory method to create an ARGB instance from separate, specified red, green, blue, and alpha components.
     * Parameter values are derived from the least significant byte.  Integer values that range outside of [0-255] may
     * give unexpected results.  For values taken from user input, sensors, or otherwise uncertain sources, consider using
     * the factory method in the Color companion object.
     *
     * @see [[ai.dragonfly.color.ARGB.getIfValid]] for a method of constructing ARGB objects with input validation.
     * @param alpha integer value from [0-255] representing the alpha component in ARGB space.  Defaults to 255.
     * @param red   integer value from [0-255] representing the red component in RGB space.
     * @param green integer value from [0-255] representing the green component in RGB space.
     * @param blue  integer value from [0-255] representing the blue component in RGB space.
     * @return an instance of the ARGB case class.
     * @example {{{ val c = ARGB(72,105,183) }}}
     */
    inline def apply(alpha: Int, red: Int, green: Int, blue: Int): ARGB = apply((alpha << 24) | (red << 16) | (green << 8) | blue)

    /**
     * Factory method to create a fully Opaque ARGB color; one with an alpha value of 255.
     * Because this method validates each intensity, it sacrifices performance
     * for safety.  Although well suited for parsing color data generated by sensors or user input, this method undercuts
     * performance in applications like reading image data.
     *
     * To skip validation and minimize overhead, @see [[ai.dragonfly.color.ARGB.apply]]
     *
     * @param red   integer value from [0-255] representing the red component in RGB space.
     * @param green integer value from [0-255] representing the green component in RGB space.
     * @param blue  integer value from [0-255] representing the blue component in RGB space.
     * @return an instance of the ARGB class or None if fed invalid input.
     */
    def getIfValid(red: Int, green: Int, blue: Int): Option[ARGB] = getIfValid(255, red, green, blue)

    /**
     * Factory method to create an ARGB color.  Because this method validates each intensity, it sacrifices performance
     * for safety.  Although well suited for parsing color data generated by sensors or user input, this method undercuts
     * performance in applications like reading image data.
     *
     * To skip validation and minimize overhead, @see [[ai.dragonfly.color.ARGB.apply]]
     *
     * @param alpha integer value from [0-255] representing the alpha component in ARGB space.
     * @param red   integer value from [0-255] representing the red component in RGB space.
     * @param green integer value from [0-255] representing the green component in RGB space.
     * @param blue  integer value from [0-255] representing the blue component in RGB space.
     * @return an instance of the C class or None if fed invalid input.
     */
    def getIfValid(alpha: Int, red: Int, green: Int, blue: Int): Option[ARGB] = {
      if (RGB.valid(alpha, red, green, blue)) Some(apply(alpha, red, green, blue))
      else None
    }

    override def weightedAverage(c1: ARGB, w1: Double, c2: ARGB, w2: Double): ARGB = {
      NRGB.weightedAverage(NRGB(c1), w1, NRGB(c2), w2).toARGB
    }

    /**
     * Generate an ARGB instance from a single value.  This method validates the intensity parameter at some cost to performance.
     *
     * @param intensity the intensity of the desired gray value ranging from [0-255].
     * @return an ARGB instance encoding the desired grayscale intensity.
     */
    inline def grayIfValid(intensity: Int): Option[ARGB] = {
      if (RGB.valid(intensity)) Some(apply(intensity, intensity, intensity))
      else None
    }

    /**
     * Generate an ARGB instance from a single value, skipping all overhead and validation.  Not suited for intensity data
     * provided by users, sensors, or other unreliable sources.
     *
     * @param intensity the intensity of the desired gray value ranging from [0-255].
     * @return an ARGB instance encoding the desired grayscale intensity.
     */
    inline def gray(intensity: Int): ARGB = apply(intensity, intensity, intensity)

    inline def CLEAR: ARGB = apply(0, 0, 0, 0)

    inline def BLACK: ARGB = apply(0, 0, 0)

    inline def WHITE: ARGB = apply(255, 255, 255)

    inline def GRAY: ARGB = apply(127, 127, 127)

    inline def DARK_GRAY: ARGB = gray(63)

    inline def LIGHT_GRAY: ARGB = gray(191)

    /**
     * Use Color.random() to obtain a random color in the form of an ARGB instance.
     * This method executes quickly and without memory costs, but the RGB color space biases toward cool colors.
     * In contrast, the Color.randomFromLabSpace() method takes seconds to initialize and has a memory footprint of several megabytes
     * However, it samples from a perceptually uniform color space and avoids the bias toward cool colors.
     * This method samples the Red, Green, and Blue color components uniformly, but always returns 255 for the alpha component.
     *
     * @return a randomly generated color sampled from the RGB Color Space.
     */
    override def random(r: scala.util.Random = Random.defaultRandom): ARGB = 0xFF000000 | r.nextInt(0xFFFFFF)
  }


  /**
   * ARGB is the primary case class for representing colors in ARGB space.
   *
   * @constructor Create a new ARGB object from an Int.
   * @see [[https://en.wikipedia.org/wiki/RGB_color_space]] for more information on the RGB color space.
   * @param argb a 32 bit integer that represents this color in ARGB space.
   *             The most significant byte encodes the alpha value, the second most significant byte encodes red,
   *             the third most significant byte encodes green, and the least significant byte encodes blue.
   * @return an instance of the ARGB case class.
   * @example {{{
   * val c = ARGB(-1)  // returns fully opaque white
   * c.toString()  // returns "ARGB(255,255,255,255)"
   * ARGB(0xFF0000FF).toString() // returns "ARGB(255,0,0,255)"
   * }}}
   */
  case class ARGB(argb: Int) extends DiscreteColor[ARGB] {
    /**
     * @return the alpha component of this color in ARGB space.
     */
    inline def alpha: Int = argb >> 24 & 0xff

    /**
     * @return the red component of this color in ARGB space.
     */
    inline def red: Int = argb >> 16 & 0xff

    /**
     * @return the green component of this color in ARGB space.
     */
    inline def green: Int = argb >> 8 & 0xff

    /**
     * @return the blue component of this color in ARGB space.
     */
    inline def blue: Int = argb & 0xff

    inline def toNRGB: NRGB = {
      NRGB(this)
    }

    override def similarity(that: ARGB): Double = Math.sqrt(
      squareInPlace(red - that.red) +
      squareInPlace(green - that.green) +
      squareInPlace(blue - that.blue)
    )

    /**
     * @return the hashcode.  For all color types, the hashcode function returns the same result as argb
     */
    override def hashCode(): Int = argb

    /**
     * @return true if these colors are equal in RGBA space, false otherwise
     */
    override def equals(obj: Any): Boolean = obj match {
      case that: ARGB => this.argb == that.argb
      case _ => false
    }

    /**
     * @return a hexadecimal string representing the rgba integer for this color.
     * @example {{{
     * val c = RGBA(72,105,183)
     * c.hex() // returns "ff4869b7"
     * }}}
     */
    def hex(): String = Integer.toHexString(argb)

    /**
     * @return a string representing the color in an html friendly way.
     * @example {{{
     * val c = RGBA(72,105,183)
     * c.html() // returns "#4869b7"
     * }}}
     */
    def html(): String = "#" + Integer.toHexString(argb | 0xff000000).substring(2)

    /**
     * @return a string representing the color in an SVG friendly way.
     * @example {{{
     * val c = RGBA(72,105,183)
     * c.svg() // returns "rgb(72,105,183)"
     * }}}
     *
     * if the color has an alpha value less than 255, in other words, if the color has any measure of translucency,
     * this method returns an rgba svg string instead of an rgb string.
     * @example {{{
     * val c = RGBA(72,105,183, 128)
     * c.svg() // returns "rgba(72,105,183,0.501960813999176)"
     * }}}
     */
    def svg(): String = {
      if (alpha < 255) s"rgba($red, $green, $blue, ${alpha / 255f})"
      else s"rgb($red, $green, $blue)"
    }

    /**
     * @return a string representing the color in a CSS friendly way.
     * @example {{{
     * val c = RGBA(72,105,183)
     * c.css() // returns "rgb(72,105,183)"
     * }}}
     *
     * if the color has an alpha value less than 255, in other words, if the color has any measure of translucency,
     * this method returns an rgba svg string instead of an rgb string.
     * @example {{{
     * val c = RGBA(72,105,183, 128)
     * c.svg() // returns "rgba(72,105,183,0.501960813999176)"
     * }}}
     */
    def css: () => String = svg

    override val toString: String = s"ARGB($alpha, $red, $green, $blue)"
  }


  object NRGB extends CommonColorSpace[NRGB] {

    def apply(values: VectorValues): NRGB = new NRGB(dimensionCheck(values, 3))

    /**
     * Factory method to create a fully opaque NARGB instance from separate, specified red, green, blue components and
     * a default alpha value of 1.0.
     * Double values that range outside of [0.0-1.0] may give unexpected results.  For values taken from user input, sensors,
     * or otherwise uncertain sources, consider using the factory method in the Color companion object.
     *
     * @see [[ai.dragonfly.color.ColorVectorSpace.NARGB]] for a method of constructing NARGB objects that validates inputs.
     * @param red   decimal value from [0.0-1.0] representing the red component in RGB space.
     * @param green decimal value from [0.0-1.0] representing the green component in RGB space.
     * @param blue  decimal value from [0.0-1.0] representing the blue component in RGB space.
     * @return an instance of the NARGB case class.
     * @example {{{ val c = NARGB(72,105,183) }}}
     */
    inline def apply(red: Double, green: Double, blue: Double): NRGB = apply(VectorValues(red, green, blue))

    val `1/255`: Double = 0.00392156862745098

    /**
     * Factory method to create a NARGB instance from an ARGB instance.
     *
     * @param argb instance of ARGB.
     * @return an instance of the NARGB case class.
     * @example {{{ val c = NARGB(72,105,183) }}}
     */
    def apply(argb: ARGB): NRGB = apply(`1/255` * argb.red, `1/255` * argb.green, `1/255` * argb.blue)

    /**
     * Factory method to create a fully Opaque NARGB color; one with an alpha value of 1.0.
     * Because this method validates each intensity, it sacrifices performance for safety.
     * Although well suited for parsing color data generated by sensors or user input, this method undercuts
     * performance in applications like reading image data.
     *
     * To skip validation and minimize overhead, @see [[ai.dragonfly.color.NRGB.apply]]
     *
     * @param red   decimal value from [0.0-1.0] representing the red component in RGB space.
     * @param green decimal value from [0.0-1.0] representing the green component in RGB space.
     * @param blue  decimal value from [0.0-1.0] representing the blue component in RGB space.
     * @return an instance of the NARGB class or None if fed invalid input.
     */

    def getIfValid(red: Double, green: Double, blue: Double): Option[NRGB] = {
      if (valid(red, green, blue)) Some(apply(red, green, blue))
      else None
    }

    inline def valid(i: Double): Boolean = 0.0 <= i && i <= 1.0

    inline def valid(red: Double, green: Double, blue: Double): Boolean = valid(red) && valid(green) && valid(blue)

    /**
     * Use Color.random() to obtain a random color in the form of an NARGB instance.
     * This method executes quickly and without memory costs, but the RGB color space biases toward cool colors.
     * In contrast, the Color.randomFromLabSpace() method takes seconds to initialize and has a memory footprint of several megabytes
     * However, it samples from a perceptually uniform color space and avoids the bias toward cool colors.
     * This method samples the Red, Green, and Blue color components uniformly, but always returns 1.0 for the alpha component.
     *
     * @return a randomly generated color sampled from the RGB Color Space.
     */
    override def random(r: scala.util.Random = Random.defaultRandom): NRGB = apply(
      VectorValues(r.nextDouble(), r.nextDouble(), r.nextDouble())
    )

    override def fromNRGB(nrgb: NRGB): NRGB = nrgb.copy()
  }

  case class NRGB private(override val values: VectorValues) extends CommonColor[NRGB] {
    override type VEC = this.type with NRGB

    inline def red: Double = values(0)

    inline def green: Double = values(1)

    inline def blue: Double = values(2)

    override val toString: String = s"NRGB($red, $green, $blue)"

    override def copy(): VEC = new NRGB(VectorValues(red, green, blue)).asInstanceOf[VEC]

    def toXYZ: XYZ = Vector3(
      (M * new Matrix(
        MatrixValues(
          VectorValues(compander.decode(red)),
          VectorValues(compander.decode(green)),
          VectorValues(compander.decode(blue))
        )
      )).getRowPackedCopy()
    )

    def toARGB: ARGB = {
      val argb = RGB.clamp( 255.0, red * 255.0, green * 255.0, blue * 255.0 )
      ARGB(argb)
    }

    inline def toNRGB: NRGB = this
  }


  object CMYK extends CommonColorSpace[CMYK] {

    def apply(values: VectorValues): CMYK = new CMYK(dimensionCheck(values, 4))

    inline def apply(cyan: Double, magenta: Double, yellow: Double, black: Double): CMYK = apply(VectorValues(cyan, magenta, yellow, black))


    inline def valid(weight: Double): Boolean = weight >= 0f && weight <= 1f

    /**
     * Factory method for creating instances of the CMYK class.
     * This method validates input parameters at the cost of some performance.
     *
     * @param cyan    a value between [0-1]
     * @param magenta a value between [0-1]
     * @param yellow  a value between [0-1]
     * @param black   a value between [0-1]
     * @return an instance of the CMYK class.
     */
    def getIfValid(cyan: Double, magenta: Double, yellow: Double, black: Double): Option[CMYK] = {
      if (valid(cyan) && valid(magenta) && valid(yellow) && valid(black)) Some(apply(cyan, magenta, yellow, black))
      else None
    }

    override def random(r: scala.util.Random = Random.defaultRandom): CMYK = apply(
      VectorValues(
        r.nextDouble(),
        r.nextDouble(),
        r.nextDouble(),
        r.nextDouble()
      )
    )

    override inline def fromNRGB(nrgb: NRGB): CMYK = {
      val K = 1.0 - Math.max(nrgb.red, Math.max(nrgb.green, nrgb.blue))
      val kInv = 1.0 - K
      val C = (1.0 - nrgb.red - K) / kInv
      val M = (1.0 - nrgb.green - K) / kInv
      val Y = (1.0 - nrgb.blue - K) / kInv

      CMYK(C, M, Y, K)
    }

  }

  /**
   * CMYK is the primary case class for representing colors in CMYK space.
   *
   * @constructor Create a new CMYK object from three Double values.  This constructor does not validate input parameters.
   *              For values taken from user input, sensors, or otherwise uncertain sources, consider using the factory method in the Color companion object.
   * @see [[ai.dragonfly.color.CMYK.getIfValid]] for a method of constructing CMYK objects that validates inputs.
   * @see [[https://en.wikipedia.org/wiki/CMYK_color_model]] for more information about the CMYK color space.
   * @param cyan    a value ranging from [0-1].  Values outside of this range may cause errors.
   * @param magenta a value ranging from [0-1].  Values outside of this range may cause errors.
   * @param yellow  a value ranging from [0-1].  Values outside of this range may cause errors.
   * @param black   a value ranging from [0-1].  Values outside of this range may cause errors.
   * @return an instance of the CMYK case class.
   * @example {{{
   * val c = CMYK(1f, 0.25f, 0.5f, 0f)
   * c.toString()  // returns "CMYK(1.000,0.250,0.500,0.000)"
   * }}}
   */

  case class CMYK private(override val values: VectorValues) extends CommonColor[CMYK] {
    override type VEC = this.type with CMYK

    inline def cyan: Double = values(0)

    inline def magenta: Double = values(1)

    inline def yellow: Double = values(2)

    inline def black: Double = values(3)

    override def toNRGB: NRGB = NRGB(
      ai.dragonfly.bitfrost.NRGB.clamp(
        (1.0 - cyan) * (1.0 - black),
        (1.0 - magenta) * (1.0 - black),
        (1.0 - yellow) * (1.0 - black)
      )
    )

    override def toString: String = s"CMYK($cyan, $magenta, $yellow, $black)"

    override def copy(): VEC = new CMYK(VectorValues(cyan, magenta, yellow, black)).asInstanceOf[VEC]
  }

  object HSL extends CommonColorSpace[HSL] {

    def apply(values: VectorValues): HSL = new HSL(dimensionCheck(values, 3))

    /**
     * HSL is the primary case class for representing colors in HSL space.
     *
     * @constructor Create a new HSV object from three Double values.  This constructor does not validate input parameters.
     *              For values taken from user input, sensors, or otherwise uncertain sources, consider using the factory method in the Color companion object.
     * @see [[ai.dragonfly.color.ColorVector.hsl]] for a method of constructing HSL objects that validates inputs.
     * @see [[https://en.wikipedia.org/wiki/HSL_and_HSV]] for more information about the HSL color space.
     * @param hue        an angle ranging from [0-360] degrees.  Values outside of this range may cause errors.
     * @param saturation a percentage ranging from [0-100].  Values outside of this range may cause errors.
     * @param lightness  a percentage ranging from [0-100].  Values outside of this range may cause errors.
     * @return an instance of the HSL case class.
     * @example {{{
     * val c = HSL(211f, 75f, 33.3333f)
     * c.toString()  // returns "HSL(211.000,75.000,33.333)"
     * }}}
     */
    inline def apply(hue: Double, saturation: Double, lightness: Double): HSL = apply(VectorValues(hue, saturation, lightness))

    override def fromNRGB(nrgb: NRGB): HSL = apply(Hue.toHSL(nrgb.red, nrgb.green, nrgb.blue))

    /**
     * Factory method for creating instances of the HSL class.  This method validates input parameters and throws an exception
     * if one or more of them lie outside of their allowed ranges.
     *
     * @param saturation an angle ranging from [0-360] degrees.
     * @param hue        a percentage ranging from [0-100].
     * @param lightness  a percentage ranging from [0-100].
     * @return an instance of the HSL case class.
     */
    def getIfValid(hue: Double, saturation: Double, lightness: Double): Option[HSL] = {
      if (Degree.valid(hue) && Saturation.valid(saturation) && Lightness.valid(lightness)) Some(apply(hue, saturation, lightness))
      else None
    }

    override def random(r: scala.util.Random = Random.defaultRandom): HSL = apply(
      VectorValues(
        r.nextDouble() * 360.0,
        r.nextDouble() * 100.0,
        r.nextDouble() * 100.0
      )
    )

  }

  case class HSL private(override val values: VectorValues) extends CommonColor[HSL] {
    override type VEC = this.type with HSL

    inline def hue: Double = values(0)

    inline def saturation: Double = values(1)

    inline def lightness: Double = values(2)

    override def copy(): VEC = new HSL(VectorValues(hue, saturation, lightness)).asInstanceOf[VEC]

    override def toNRGB: NRGB = {
      val C = (1.0 - Math.abs(2.0 * (lightness / 100.0) - 1.0)) * (saturation / 100.0)
      NRGB.apply(Hue.hcxmToNRGBvalues(hue, C, Hue.hcToX(hue, C), (lightness / 100.0) - (C / 2.0)))
    }

    override val toString: String = s"HSL($hue, $saturation, $lightness)"

    /**
     * @return a string representing the color in an SVG friendly way.
     * @example {{{
     * val c = HSL(211f, 75f, 33.3333f)
     * c.svg() // returns "hsl(211.000,75.0%,33.3%)"
     * }}}
     */
    def svg(): String = s"hsl(${f"$hue%1.3f"}, ${f"$saturation%1.1f"}%, ${f"$lightness%1.1f"}%)"
  }

  object HSV extends CommonColorSpace[HSV] {

    def apply(values: VectorValues): HSV = new HSV(dimensionCheck(values, 3))

    /**
     * HSV is the primary case class for representing colors in HSV space.
     *
     * @constructor Create a new HSV object from three Double values.  This constructor does not validate
     *              input parameters.  For values taken from user input, sensors, or otherwise uncertain sources, consider using
     *              the factory method in the Color companion object.
     * @see [[ai.dragonfly.color.HSV.getIfValid]] for a method of constructing HSV objects that validates inputs.
     * @see [[https://en.wikipedia.org/wiki/HSL_and_HSV]] for more information about the HSV color space.
     * @param hue        an angle ranging from [0-360] degrees.  Values outside of this range may cause errors.
     * @param saturation a percentage ranging from [0-100].  Values outside of this range may cause errors.
     * @param value      a percentage ranging from [0-100].  Values outside of this range may cause errors.
     * @return an instance of the HSV case class.
     * @example {{{
     * val c = HSV(211f, 75f, 33.3333f)
     * c.toString()  // returns "HSV(211.000,75.000,33.333)"
     * }}}
     */

    inline def apply(hue: Double, saturation: Double, value: Double): HSV = apply(VectorValues(hue, saturation, value))

    /**
     * Factory method for creating instances of the HSV class.  This method validates input parameters and throws an exception
     * if one or more of them lie outside of their allowed ranges.
     *
     * @param saturation an angle ranging from [0-360] degrees.
     * @param hue        a percentage ranging from [0-100].
     * @param value      a percentage ranging from [0-100].
     * @return an instance of the HSV case class.
     */
    def getIfValid(hue: Double, saturation: Double, value: Double): Option[HSV] = {
      if (Hue.valid(hue) && Saturation.valid(saturation) && Value.valid(saturation)) Some(apply(hue, saturation, value))
      else None
    }

    override def fromNRGB(nrgb: NRGB): HSV = apply(Hue.toHSV(nrgb.red, nrgb.green, nrgb.blue))

    override def random(r: scala.util.Random = Random.defaultRandom): HSV = apply(
      VectorValues(
        r.nextDouble() * 360.0,
        r.nextDouble() * 100.0,
        r.nextDouble() * 100.0
      )
    )

  }

  case class HSV private(override val values: VectorValues) extends CommonColor[HSV] {
    override type VEC = this.type with HSV

    inline def hue: Double = values(0)

    inline def saturation: Double = values(1)

    inline def value: Double = values(2)

    override def toNRGB: NRGB = {
      val C = (value / 100.0) * (saturation / 100.0)
      NRGB.apply(Hue.hcxmToNRGBvalues(hue, C, Hue.hcToX(hue, C), (value / 100.0) - C))
    }

    override def copy(): VEC = new HSV(VectorValues(hue, saturation, value)).asInstanceOf[VEC]

    override val toString: String = s"HSV($hue, $saturation, $value)"
  }


  object Lab extends PerceptualColorSpace[Lab] {
    def apply(values: VectorValues): Lab = new Lab(dimensionCheck(values, 3))

    override def random(r: scala.util.Random = Random.defaultRandom): Lab = ???

    /**
     * @param L the L* component of the CIE L*a*b* color.
     * @param a the a* component of the CIE L*a*b* color.
     * @param b the b* component of the CIE L*a*b* color.
     * @return an instance of the LAB case class.
     * @example {{{ val c = LAB(72.872, -0.531, 71.770) }}}
     */
    inline def apply(L: Double, a: Double, b: Double): Lab = apply(VectorValues(L, a, b))

    inline def f(t: Double): Double = if (t > ϵ) Math.cbrt(t) else (t * `k/116`) + `16/116`

    /**
     * Requires a reference 'white' because although black provides a lower bound for XYZ values, they have no upper bound.
     *
     * @param xyz
     * @param illuminant
     * @return
     */
    def fromXYZ(xyz: XYZ): Lab = {
      val fy: Double = f(illuminant.`1/Yn` * xyz.y)

      apply(
        116.0 * fy - 16.0,
        500.0 * (f(illuminant.`1/Xn` * xyz.x) - fy),
        200.0 * (fy - f(illuminant.`1/Zn` * xyz.z)),
      )
    }
  }

  case class Lab private(override val values: VectorValues) extends PerceptualColor[Lab] {
    override type VEC = this.type with Lab

    override def copy(): VEC = new Lab(VectorValues(L, a, b)).asInstanceOf[VEC]

    inline def L: Double = values(0)

    inline def a: Double = values(1)

    inline def b: Double = values(2)

    inline def fInverse(t: Double): Double = if (t > `∛ϵ`) t * t * t else (`116/k` * t) - `16/k`

    def toXYZ(using workingSpace: WorkingSpace): Vector3 = {
      val white: Vector3 = workingSpace.illuminant.vector
      val fy: Double = `1/116` * (L + 16.0)

      Vector3(
        fInverse((0.005 * a) + fy) * white.x, // X
        (if (L > kϵ) {
          val l = L + 16.0; `1/116³` * (l * l * l)
        } else `1/k` * L) * white.y, // Y
        fInverse(fy - (0.002 * b)) * white.z, // X
      )
    }

    override def toString: String = s"L*a*b*($L,$a,$b)"
  }


  object Luv extends PerceptualColorSpace[Luv] {

    def apply(values: VectorValues): Luv = new Luv(dimensionCheck(values, 3))

    /**
     * @constructor Create a new SlowSlimLuv object from three float values.  This constructor does not validate input parameters.
     * @param L the L* component of the CIE L*u*v* color.
     * @param u the u* component of the CIE L*u*v* color.
     * @param v the v* component of the CIE L*u*v* color.
     * @return an instance of the SlowSlimLuv case class.
     * @example {{{ val c = SlowSlimLuv(14.756, -3.756, -58.528) }}}
     */

    inline def apply(L: Double, u: Double, v: Double): Luv = apply(VectorValues(L, u, v))


    override def random(r: scala.util.Random = Random.defaultRandom): Luv = ???

    // XYZ to LUV and helpers:
    inline def fL(t: Double): Double = if (t > ϵ) 116.0 * Math.cbrt(t) - 16.0 else k * t

    inline def fromXYZ(xyz: Vector3): Luv = {
      val white: Vector3 = illuminant.vector
      val scale: Double = XYZ.transform(xyz)
      val referenceWhiteScale: Double = XYZ.transform(white)
      apply(
        fL(xyz.y), // L*  // y / illuminant.Yn, but all known illuminants have Yn = 1.0
        fL(4.0 * ((xyz.x * scale) - (white.x * referenceWhiteScale))), // u
        fL(9.0 * ((xyz.y * scale) - (white.y * referenceWhiteScale))) // v
      )
    }

  }


  /**
   * LUV is the base trait for classes that encode colors in the CIE L*u*v* color space.
   *
   * @see [[https://en.wikipedia.org/wiki/CIELUV]] for more information on CIE L*u*v*.
   */

  case class Luv private(override val values: VectorValues) extends PerceptualColor[Luv] {
    override type VEC = this.type with Luv

    inline def L: Double = values(0)

    inline def u: Double = values(1)

    inline def v: Double = values(2)

    override def toString: String = s"L*u*v*($L,$u,$v)"

    override def copy(): VEC = new Luv(VectorValues(L, u, v)).asInstanceOf[VEC]

    // LUV to XYZ and helpers:
    inline def flInverse(t: Double): Double = if (t > kϵ) {
      `1/116³` * cubeInPlace(t + 16.0) // ((L+16)/116)^3 = (L + 16)^3 / 116^3 = (L + 16)^3 / 1560896.0
    } else t / k

    inline def toXYZ(using workingSpace: WorkingSpace): Vector3 = {
      val `1/3`: Double = 0.3333333333333333 // = 1.0/3.0
      val white: Vector3 = workingSpace.illuminant.vector
      val referenceWhiteScale: Double = XYZ.transform(white)
      val Y: Double = flInverse(L)
      val a: Double = `1/3` * ((52.0 * L) / (u + (52.0 * L * (white.x * referenceWhiteScale))) - 1.0) // 13 * 4 = 52
      val b: Double = -5.0 * Y
      //val c:Double = -`1/3`
      val d: Double = Y * (((39.0 * L) / (v * (117.0 * L * (white.y * referenceWhiteScale)))) - 5.0)
      val X: Double = (d - b) / (a + `1/3`)
      Vector3(X, Y, X * (a + b))
    }

  }


  def argbToHueMaxMin[C](argb: ARGB)(factory: (Double, Double, Double) => C): C = {
    //  1/255 = 0.00392156862745098
    val r = argb.red * 0.00392156862745098f
    val g = argb.green * 0.00392156862745098f
    val b = argb.blue * 0.00392156862745098f

    val min: Double = Math.min(r, Math.min(g, b))
    val MAX: Double = Math.max(r, Math.max(g, b))

    val delta: Double = MAX - min

    val h: Double = (if (delta == 0.0) {
      0
    } else {
      (60.0 * (
        if (r == MAX) {
          ((g - b) / delta) % 6
        } else if (g == MAX) {
          ((b - r) / delta) + 2
        } else {
          ((r - g) / delta) + 4
        }
        )) + 360
    }) % 360

    factory(h, min, MAX)
  }

  given Conversion[java.awt.Color, ARGB] with
    def apply(jac: java.awt.Color): ARGB = ARGB(jac.getRGB())

  given Conversion[ARGB, java.awt.Color] with
    def apply(c: ARGB): java.awt.Color = new java.awt.Color(c.argb, true)

  given Conversion[Int, ARGB] with
    def apply(argb: Int): ARGB = ARGB(argb)

  given Conversion[ARGB, Int] with
    def apply(c: ARGB): Int = c.argb

  given Conversion[ARGB, HSV] with
    def apply(c: ARGB): HSV = argbToHueMaxMin[HSV](c)(
      (hue: Double, min: Double, MAX: Double) => HSV(hue, 100 * (MAX - min) / MAX, 100f * MAX)
    )


  given Conversion[ARGB, HSL] with
    def apply(c: ARGB): HSL = argbToHueMaxMin[HSL](c)(
      (hue: Double, min: Double, MAX: Double) => {
        val delta = MAX - min
        val L = (MAX + min) / 2f
        val denom = 1f - Math.abs(2 * L - 1)
        val S = if (denom <= 0f) 0 else delta / denom
        HSL(hue, 100f * S, 100f * L)
      }
    )


  given Conversion[ARGB, CMYK] with
    def apply(c: ARGB): CMYK = {
      //  1/255 = 0.00392156862745098
      val r = c.red * 0.00392156862745098f
      val g = c.green * 0.00392156862745098f
      val b = c.blue * 0.00392156862745098f

      val K = 1.0 - Math.max(r, Math.max(g, b))
      val kInv = 1.0 - K
      val C = (1.0 - r - K) / kInv
      val M = (1.0 - g - K) / kInv
      val Y = (1.0 - b - K) / kInv

      CMYK(C, M, Y, K)
    }

}
